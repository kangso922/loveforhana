<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <!-- 필수 Open Graph 태그들 -->
    <meta property="og:title" content="하나의 그림 갤러리 🎨" />
    <meta property="og:description" content="하나떵개의 감성 갤러리 🌸 조용히 감상해요." />
    <meta property="og:image" content="https://kangso922.github.io/loveforhana/images/image8.jpg" />
    <meta property="og:url" content="https://kangso922.github.io/" />
    <meta property="og:type" content="website" />
    <title>하나의 그림 갤러리 🎨</title>
    <link rel="stylesheet" href="style.css"/>
    <link href="https://fonts.googleapis.com/css2?family=Gamja+Flower&display=swap" rel="stylesheet"/>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J16EN3BDWW"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-J16EN3BDWW');
    </script>
</head>
<body>
<div class="player">
    <audio id="player" src="music/bgm.mp3"></audio>
    <button onclick="togglePlay()" id="playPauseBtn" class="play">♫</button>
    <div id="bar" class="bar"></div>
</div>
<div class="container">
    <h1>하나떵개의 그림들 ✨</h1>
    <div class="gallery">
        <div class="item"><img src="images/image1.jpg" alt="그림 1"/></div>
        <div class="item"><img src="images/image2.jpg" alt="그림 2"/></div>
        <div class="item"><img src="images/image3.jpg" alt="그림 3"/></div>
        <div class="item"><img src="images/image4.jpg" alt="그림 4"/></div>
        <div class="item"><img src="images/image6.jpg" alt="그림 6"/></div>
        <div class="item"><img src="images/image7.jpg" alt="그림 7"/></div>
        <div class="item"><img src="images/image8.jpg" alt="그림 8"/></div>
        <div class="item"><img src="images/image5.jpg" alt="그림 5"/></div>
    </div>

    <!--<div class="music-control">
        <button onclick="document.getElementById('bgm').play()">🎵 음악 듣기</button>
    </div>-->
</div>

<!-- 모달 -->
<div class="modal" id="modal">
    <span class="close" id="close">×</span>
    <img class="modal-content" id="modal-img"/>
</div>

<audio id="bgm" loop>
    <source src="music/bgm.mp3" type="audio/mpeg"/>
    브라우저가 오디오를 지원하지 않습니다.
</audio>

<script>
    const modal = document.getElementById('modal');
    const modalImg = document.getElementById('modal-img');
    const closeBtn = document.getElementById('close');
    const audio = document.getElementById("player");
    const playPauseBtn = document.getElementById("playPauseBtn");
    const bar = document.getElementById("bar");

    let scrollY = 0;
    let petalIntervalId = null; // 벚꽃 생성 interval ID 저장용

    // --- 모달 열기 이벤트 리스너 ---
    document.querySelectorAll('.item img').forEach(img => {
        img.addEventListener('click', () => {
            // 1. 모달 이미지 로드 완료 시 처리할 내용 정의 (onload 핸들러)
            modalImg.onload = () => {
                console.log("Modal image loaded:", modalImg.src);
                // 로드 완료 후, 좌표 계산 및 효과 생성
                const rect = modalImg.getBoundingClientRect();
                createHeartsFromBox(rect.left, rect.top, rect.width, rect.height);
                createParticlesFromBox(rect.left, rect.top, rect.width, rect.height);
                // 핸들러 초기화 (다음 이미지 로드를 위해)
                modalImg.onload = null;
                modalImg.onerror = null;
            };
            // 이미지 로드 실패 시 처리
            modalImg.onerror = () => {
                console.error("Failed to load modal image:", modalImg.src);
                modalImg.onload = null;
                modalImg.onerror = null;
            };

            // 2. 이미지 소스 설정 (onload 핸들러 설정 후)
            modalImg.src = img.src;

            // 3. 현재 스크롤 위치 저장 및 body 고정
            scrollY = window.scrollY;
            document.body.style.position = 'fixed';
            document.body.style.top = `-${scrollY}px`;
            document.body.style.left = '0';
            document.body.style.right = '0';
            document.body.style.width = '100%';

            // 4. 모달 표시
            modal.style.display = 'flex';

            // 5. 세션 스토리지에 상태 저장
            sessionStorage.setItem('scrollY', scrollY);
            sessionStorage.setItem('isModalOpen', 'true');
            sessionStorage.setItem('modalImage', img.src);

            // !!! 중요: 하트/파티클 생성 호출은 onload 핸들러 안으로 이동했으므로 여기서는 제거 !!!
            // setTimeout(() => { ... }, 0); 부분 삭제됨
        });
    });

    // --- 모달 닫기 ---
    function closeModal() {
        modal.style.display = 'none';
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.left = '';
        document.body.style.right = '';
        document.body.style.width = '';
        // 저장된 스크롤 위치 복원 전에 약간의 지연이 필요할 수 있음 (렌더링 시간 확보)
        // requestAnimationFrame(() => window.scrollTo(0, scrollY));
        window.scrollTo(0, scrollY); // 일단 바로 복원 시도
        sessionStorage.setItem('isModalOpen', 'false');
    }

    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (event) => {
        if (event.target === modal) {
            closeModal();
        }
    });

    // --- 하트 생성 함수 ---
    function createHeartsFromBox(x, y, width, height) {
        // !!! 중요: .complete 체크 제거 !!! (onload에서 호출되므로)
        // if (!document.getElementById('modal-img').complete) { ... } 부분 삭제됨

        fetch("images/heart-svgrepo-com.svg?cache=" + Date.now())
            .then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                return res.text();
            })
            .then(svgText => {
                let cleanedSvg = svgText
                    .replace(/<svg([^>]*)width="[^"]*"([^>]*)>/, '<svg$1$2>')
                    .replace(/<svg([^>]*)height="[^"]*"([^>]*)>/, '<svg$1$2>')
                    .replace(/fill="none"/g, 'fill="#ff6b81"')
                    .replace(/stroke="#[^"]*"/g, 'stroke="none"');

                const centerX = x + width / 2;
                const centerY = y + height / 2;
                const maxRadius = Math.min(width, height) * 0.6;

                for (let i = 0; i < 10; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = Math.random() * maxRadius;
                    const offsetX = Math.cos(angle) * radius;
                    const offsetY = Math.sin(angle) * radius;
                    const posX = centerX + offsetX;
                    const posY = centerY + offsetY;

                    const wrapper = document.createElement("div");
                    wrapper.classList.add("floating-heart");
                    wrapper.style.position = "fixed";
                    wrapper.style.left = `${posX}px`;
                    wrapper.style.top = `${posY}px`;
                    wrapper.style.width = "32px";
                    wrapper.style.height = "32px";
                    wrapper.innerHTML = cleanedSvg;

                    document.body.appendChild(wrapper);
                    setTimeout(() => wrapper.remove(), 1500);
                }
            }).catch(error => console.error("Error fetching or processing heart SVG:", error));
    }

    // --- 파티클 생성 함수 ---
    function createParticlesFromBox(x, y, width, height) {
        // !!! 중요: .complete 체크 제거 !!! (onload에서 호출되므로)
        // if (!document.getElementById('modal-img').complete) { ... } 부분 삭제됨

        for (let i = 0; i < 12; i++) {
            const particle = document.createElement('div');
            particle.classList.add('particle');

            const angle = Math.random() * 2 * Math.PI;
            const radius = Math.random() * Math.min(width, height) * 0.6;
            const offsetX = Math.cos(angle) * radius;
            const offsetY = Math.sin(angle) * radius;

            const px = x + width / 2 + offsetX;
            const py = y + height / 2 + offsetY;

            particle.style.left = `${px}px`;
            particle.style.top = `${py}px`;
            particle.style.position = 'fixed';

            const moveAngle = Math.random() * 2 * Math.PI;
            const dist = Math.random() * 60 + 20;

            particle.style.setProperty('--dest-x', `${Math.cos(moveAngle) * dist}px`);
            particle.style.setProperty('--dest-y', `${Math.sin(moveAngle) * dist}px`);
            particle.style.background = ['#ffc1cc', '#ffd6e8', '#ffb3b3', '#ffe4ec'][Math.floor(Math.random() * 4)];

            document.body.appendChild(particle);
            setTimeout(() => particle.remove(), 800);
        }
    }

    // --- 벚꽃잎 생성 함수 ---
    function createPetal() {
        const petal = document.createElement("div");
        petal.classList.add("petal");
        petal.innerText = "🌸";
        const startLeft = Math.random() * window.innerWidth;
        const size = Math.random() * 14 + 12;
        const duration = Math.random() * 5 + 5;
        const delay = Math.random() * 5;
        const xDrift = Math.random() * 100 - 50 + "px";
        petal.style.left = `${startLeft}px`;
        petal.style.fontSize = `${size}px`;
        petal.style.animationDuration = `${duration}s`;
        petal.style.animationDelay = `${delay}s`;
        petal.style.setProperty('--x-drift', xDrift);
        document.body.appendChild(petal);
        setTimeout(() => petal.remove(), (duration + delay) * 1000);
    }

    // --- 오디오 재생/일시정지 토글 ---
    function togglePlay() {
        if (!audio) return;
        if (audio.paused) {
            audio.play().then(() => {
                playPauseBtn.textContent = "🔇";
                bar.style.display = "block";
                sessionStorage.setItem('audioPaused', 'false');
                sessionStorage.setItem('audioTime', audio.currentTime);
            }).catch(error => {
                console.error("Audio play failed:", error);
                playPauseBtn.textContent = "♫";
                bar.style.display = "none";
                sessionStorage.setItem('audioPaused', 'true');
            });
        } else {
            audio.pause();
            playPauseBtn.textContent = "♫";
            bar.style.display = "none";
            sessionStorage.setItem('audioPaused', 'true');
            sessionStorage.setItem('audioTime', audio.currentTime);
        }
    }
    playPauseBtn.addEventListener('click', togglePlay);

    // --- 상태 복원 함수 (유일한 정의, 오디오 복원 포함) ---
    // HTML <script>의 restoreAppState 함수 수정 (극도로 상세한 로깅)

    function restoreAppState() {
        console.log('[Web] +++++ restoreAppState START +++++');
        try {
            // --- 1. 값 읽기 ---
            const lastScroll = sessionStorage.getItem('scrollY');
            const isModalOpen = sessionStorage.getItem('isModalOpen');
            const modalImage = sessionStorage.getItem('modalImage');
            const audioPaused = sessionStorage.getItem('audioPaused');
            const audioTime = sessionStorage.getItem('audioTime');
            console.log('[Web] 1. Read from sessionStorage:', { lastScroll, isModalOpen, modalImage, audioPaused, audioTime });

            // --- 2. 스크롤 복원 ---
            if (lastScroll) {
                const scrollVal = parseInt(lastScroll);
                console.log('[Web] 2. Attempting scroll restore to:', scrollVal);
                // 스크롤은 비동기 렌더링 고려하여 지연 유지
                setTimeout(() => {
                    window.scrollTo(0, scrollVal);
                    console.log('[Web] 2. Scroll restoration attempted. Current scrollY:', window.scrollY);
                }, 100);
            } else {
                console.log('[Web] 2. No saved scroll position.');
            }

            // --- 3. 모달 복원 ---
            console.log('[Web] 3. Checking modal state. isModalOpen:', isModalOpen, 'modalImage:', modalImage);
            if (isModalOpen === 'true' && modalImage) {
                console.log('[Web] 3.1. Attempting to restore modal.');
                modalImg.onload = () => {
                    console.log('[Web] 3.2. Modal image loaded.');
                    modal.style.display = 'flex';
                    document.body.style.position = 'fixed';
                    const topOffset = `-${lastScroll || 0}px`;
                    document.body.style.top = topOffset;
                    document.body.style.left = '0';
                    document.body.style.right = '0';
                    document.body.style.width = '100%';
                    console.log('[Web] 3.3. Modal displayed and body fixed. Top:', topOffset);
                    modalImg.onload = null;
                    modalImg.onerror = null;
                };
                modalImg.onerror = () => {
                    console.error("[Web] 3.E. Failed to load modal image for restoration:", modalImage);
                    modalImg.onload = null;
                    modalImg.onerror = null;
                };
                modalImg.src = modalImage; // 핸들러 설정 후 src 지정
                console.log('[Web] 3.4. Modal image src set.');
            } else {
                console.log('[Web] 3.5. Ensuring modal is closed.');
                modal.style.display = 'none';
                document.body.style.position = '';
                document.body.style.top = '';
                document.body.style.left = '';
                document.body.style.right = '';
                document.body.style.width = '';
            }

            // --- 4. 오디오 복원 ---
            console.log('[Web] 4. Checking audio state. audioPaused:', audioPaused);
            if (audio) {
                const targetTime = audioTime ? parseFloat(audioTime) : 0;
                console.log('[Web] 4.1. Target audio time:', targetTime);
                // 오디오 로드 상태 확인 후 시간 설정 시도 (더 안정적)
                if (audio.readyState >= 1) { // HAVE_METADATA or higher
                    audio.currentTime = targetTime;
                    console.log('[Web] 4.2. Set audio currentTime to:', audio.currentTime);
                } else {
                    // 로드가 안됐으면 로드 후 시간 설정 시도
                    audio.onloadedmetadata = () => {
                        audio.currentTime = targetTime;
                        console.log('[Web] 4.2. (onloadedmetadata) Set audio currentTime to:', audio.currentTime);
                        audio.onloadedmetadata = null; // 핸들러 제거
                    }
                }

                if (audioPaused === 'false') {
                    console.log('[Web] 4.3. Attempting to play audio.');
                    // play()는 사용자의 상호작용 후에만 성공할 가능성이 높음 (특히 모바일)
                    audio.play().then(() => {
                        playPauseBtn.textContent = "🔇";
                        bar.style.display = "block";
                        console.log('[Web] 4.4. Audio play success.');
                    }).catch(error => {
                        console.error("[Web] 4.E. Audio play failed on restore:", error);
                        playPauseBtn.textContent = "♫";
                        bar.style.display = "none";
                        sessionStorage.setItem('audioPaused', 'true'); // 실패 시 상태 업데이트
                    });
                } else {
                    console.log('[Web] 4.5. Setting audio to paused.');
                    audio.pause();
                    playPauseBtn.textContent = "♫";
                    bar.style.display = "none";
                }
            } else {
                console.warn("[Web] 4.W. Audio element #player not found.");
            }
        } catch (error) {
            // 함수 실행 중 발생한 모든 오류 로깅
            console.error('[Web] !!!!! CRITICAL Error inside restoreAppState !!!!!', error, error.stack);
        } finally {
            console.log('[Web] ----- restoreAppState END -----');
        }
    }

    // --- !!! 중요: 전역 오류 핸들러 추가 !!! ---
    window.onerror = function(message, source, lineno, colno, error) {
        console.error("[Web] Global Uncaught Error:", {
            message: message,
            source: source,
            lineno: lineno,
            colno: colno,
            errorObject: error
        });
        // 오류 발생 시 true를 반환하면 브라우저 콘솔에 기본 오류 메시지가 표시되지 않도록 할 수 있음
        // return true;
    };

    window.addEventListener('unhandledrejection', function(event) {
        console.error('[Web] Global Unhandled Promise Rejection:', event.reason);
    });


    // --- 페이지 가시성 변경 처리 ---
    function handleVisibilityChange() {
        if (document.hidden) {
            console.log("Page is hidden");
            if (petalIntervalId) {
                clearInterval(petalIntervalId);
                petalIntervalId = null;
                console.log("Petal interval cleared.");
            }
            // 선택적: 음악 일시정지
            // if (audio && !audio.paused) { togglePlay(); }
        } else {
            console.log("Page is visible");
            if (!petalIntervalId) {
                petalIntervalId = setInterval(createPetal, 500);
                console.log("Petal interval restarted.");
            }
            // 선택적: 페이지 보일 때 상태 재확인/복원
            // restoreAppState();
        }
    }
    document.addEventListener("visibilitychange", handleVisibilityChange);

    // --- 스크롤 위치 저장 ---
    window.addEventListener('scroll', () => {
        if (document.body.style.position !== 'fixed') {
            sessionStorage.setItem('scrollY', window.scrollY);
        }
    });

    // --- 페이지 로드 완료 시 ---
    window.addEventListener('load', () => {
        console.log("Page finished loading.");
        // 선택적: 초기 상태 복원 시도
        // restoreAppState();
        // 불필요 플러터 통신 코드 제거됨
    });

    // --- 안드로이드에서 호출 가능하도록 함수 전역 노출 ---
    window.restoreAppState = restoreAppState;

    // --- 최초 벚꽃 생성 시작 ---
    if (!petalIntervalId) {
        petalIntervalId = setInterval(createPetal, 500);
    }

    // !!! 중요: 스크립트 끝에 있던 중복 restoreAppState 함수 정의 제거됨 !!!

</script>
</body>
</html>
